#Python, like most languages, actually uses numbers in the 
#background to represent individual characters in a string. 
#For example, "a" is assigned the numeric value of 97. 
#We call this the ordinal value. www.asciitable.com shows
#a table of ordinal values: the ordinal value is listed in
#the 'dec' column, and the actual character is listed in
#'chr' column.

#
#You'll notice, though, that many of the characters here
#are weird. The first 31 are cryptic characters that have
#special meaning to the computer. The extended codes haven't
#really been used since Windows came along. Beyond these
#255, the higher numbers are actually used to represent
#emojis.
#
#Now, think about when you're asked to create a password.
#Typically, there are restrictions on what characters you
#can use. How do you check if a password is valid? You
#could have a list of valid characters and check each
#character against that list, but that would be a really
#long list. Instead, let's use ordinal values.
#
#Write a function called "valid_char" that determines
#if a single character (a string of length one) has an
#ordinal value corresponding to a valid character for a
#password. Valid characters are any character on the
#keyboard except spaces. Return True if it's a valid
#character, False if it is not.
#
#Hint: you can find the ordinal value of a character using 
#the built-in Python function ord(): ord("a") -> 97
#
#Hint 2: the range of legal characters will be one
#continuous range (e.g. characters 55 through 65, not
#separate ranges like 55 through 65 and 69 through 79).
#You can use asciitable.com to look up what range you
#should use.


#Write your function here!
def valid_char(char):
    value = ord(char)
    for i in range(33,126):
        if value >= i and value <= 126:
          return True
        else:
          return False
        



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: True, False, True, False

print(valid_char("a"))
print(valid_char(" "))
print(valid_char("!"))
print(valid_char("?"))

===============================================================  2
#Write function called third_character that accepts a
#string as an argument and returns the third character
#of the string. If the user inputs a string with fewer than
#3 characters, return "Too short". 


#Write your function here!

def third_character(myString):
    value = len(myString)
    if(value < 3):
        return "Too short"
    else:
        return myString[2]



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 1, o, and "Too short", each on a different line.
print(third_character("CS1301"))
print(third_character("Georgia Tech"))
print(third_character("GT"))

===============================================================  3
#Write a function called "num_changer" that accepts a string 
#of digits (0-9). You should make an integer from the digits 
#of the even indices and another number from the digits in 
#the odd indices. Return the sum of these two numbers. You 
#can assume the given string will have a length of at least 
#2 digits.
#
#For example, if the string was "123456", you would split
#this into two integers, 135 and 246. Adding them would give
#381. Or if the string was "13579", you would split this into
#159 and 37, then add them to get 196.
#
#Hint: You can do this with loops, but it's easier to do
#this with string slicing. Remember how we could pass a third
#argument to range() that would tell range how many numbers
#to skip? You can do something similar with string slices: if
#you include second colon in a string slice, the number
#that follows it lets you skip characters in the string. For
#example:
#
# "Hello, world!"[1:9] -> This gives "ello, wo".
# "Hello, world!"[1:9:2] -> This gives "el,w". Including :2
#    in the string slice skips every other letter. 
# "Hello, world!" [::3] -> This gives "Hl r!". Leaving the
#    first two spots blank tells it to look at the entire
#    string, but putting :3 at the end says to only take
#    every third character (H, l, space, r, and !).
#
#Hint 2: Remember, Python is zero-indexed. That means the
#first number in the string is at position 0, and so it goes
#in the even list.


#Write your function here!
def num_changer(digits):
    odd = ""
    even = ""
    value = 0
    for characher in range (len(digits)):
        value = int(characher)
        if value % 2 == 0:
            even += digits[characher]
        else:
            odd += digits[characher]
        
    return int(even) + int(odd) 

            



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 123456 -> 381
string_int = "123456"
result = num_changer(string_int)
print(string_int + " -> " + str(result))

======================================================================  4
#Write a function called "in_parentheses" that accepts a 
#single argument, a string representing a sentence that
#contains some words in parentheses. Your function should
#return the contents of the parentheses.
#
#For example:
#
# in_parentheses("This is a sentence (words!)") -> "words!"
#
#If no text appears in parentheses, return an empty string.
#Note that there are several edge cases introduced by this:
#all of the following function calls would return an empty
#string:
#
# in_parentheses("No parentheses")
# in_parentheses("Open ( only")
# in_parentheses("Closed ) only")
# in_parentheses("Closed ) before ( open")
#
#You may assume, however, that there will not be multiple
#open or closed parentheses.

openTag = 0
closeTag = 0

#Write your function here!
def in_parentheses(sentence):
    emptyString = False

    openTag = str.find(sentence,'(')

    closeTag = str.find(sentence,')')

    if( openTag >= 0 and  closeTag >= 0):
        return sentence[openTag+1:closeTag]
    else:
        return ''




#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (including the blank lines):
#words!
#
#as he is doing right now
#
#
#!

print(in_parentheses("This is a sentence (words!)."))
print(in_parentheses("No parentheses here!"))
print(in_parentheses("David tends to use parentheses a lot (as he is doing right now). It tends to be quite annoying."))
print(in_parentheses("Open ( only"))
print(in_parentheses("Closed ) only"))
print(in_parentheses("Closed ) before ( open"))
print(in_parentheses("That's a lot of test cases(!)"))

======================================================================  5
#Write a function called 'string_type' which accepts one
#string argument and determines what type of string it is. 
#
# - If the string is empty, return "empty".
# - If the string is a single character, return "character".
# - If the string represents a single word, return "word".
#   The string is a single word if it has no spaces.
# - If the string is a whole sentence, return "sentence".
#   The string is a sentence if it contains spaces, but
#   at most one period.
# - If the string is a paragraph, return "paragraph". The
#   string is a paragraph if it contains both spaces and
#   multiple periods (we won't worry about other
#   punctuation marks).
# - If the string is multiple paragraphs, return "page".
#   The string is a paragraph if it contains any newline
#   characters ("\n").
#
#Hint: think carefully about what order you should check
#these conditions in.
#
#Hint 2: remember, there exists a count() method that
#counts the number of times a string appears in another
#string. For example, "blah blah blah".count("blah")
#would return 3.


#Write your function here!
def string_type(stringparameter):
    if not stringparameter:
        return 'empty'
    elif len(stringparameter) == 1:
        return 'character'
    elif stringparameter.count(' ') == 0:
        return 'word'
    elif stringparameter.count('\n') > 0 :
        return 'page'
    elif stringparameter.count(' ') > 5:
        return 'paragraph'
    elif stringparameter.find(' '):
        return 'sentence'
   


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#empty
#character
#word
#sentence
#paragraph
#page
print(string_type(""))
print(string_type("!"))
print(string_type("CS1301."))
print(string_type("This is too many cases!"))
print(string_type("There's way too many ostriches. Why are there so many ostriches. The brochure said there'd only be a few ostriches."))
print(string_type("Paragraphs need to have multiple sentences. It's true.\nHowever, two is enough. Yes, two sentences can make a paragraph."))

========================================================================================  6
#Recall that input from a user is always in the form of a string. 
#Write a function called "input_type" that gets user input and 
#determines what kind of string the user entered. The user input
#will be supplied as an argument to the function like normal.
#
#  - Your function should return "integer" if the string only
#    contains characters 0-9.
#  - Your function should return "float" if the string only
#    contains the numbers 0-9 and at most one period.
#  - You should return "boolean" if the user enters "True" or
#    "False". 
#  - Otherwise, you should return "string".


#Write your function here!

def input_type(string_input):

    if '.' in string_input:
        return 'float'    
    elif 'True' in string_input or 'False' in string_input:
        return 'boolean'
    elif string_input.isdigit():
        return 'integer'
    elif type(string_input) == str:
        return 'string' 
  
    



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#string
#boolean
#float
#integer
print(input_type(""))
print(input_type("False"))
print(input_type("7.432621"))
print(input_type("2788"))

=======================================================================================  7
#Write a function called "quote_this" that accepts two 
#strings as arguments: a string representing a quote and
#a string of a name. The function should return a new
#string with the quote surrounded by quotation marks (")
#followed by a dash and the given name. For example:
#
#a = quote_this("Try and fail, but never fail to try.",
#"Jared Leto")
#print(a) 
#
#Will print:
#"Try and fail, but never fail to try." -Jared Leto
#
#If the code were to continue, this:
#
#b = quote_this(a, "Michael Scott")
#print(b)
#
#Would print:
#""Try and fail, but never fail to try." -Jared Leto"
#- Michael Scott


#Write your function here!
def quote_this(quate, author): 
     name = ''
     name +=  '\"' + quate  + '\"' + ' -' + author
     return name
    



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print the same output as the examples above.
a = quote_this("Try and fail, but never fail to try.", "Jared Leto")
print(a) 
b = quote_this(a, "Michael Scott")
print(b)

===========================================================================  8
#Write a function called string_finder. string_finder should
#take two parameters: a target string and a search string.
#The function will look for the search string within the
#target string.
#
#The function should return a string representing where in
#the target string the search string was found:
#
# - If search string is at the very beginning of target
#   string, then return "Beginning". For example:
#   string_finder("Georgia Tech", "Georgia") -> "Beginning"
#
# - If search string is at the very end of target string,
#   then return "End". For example:
#   string_finder("Georgia Tech", "Tech") -> "End"
#
# - If search string is in target string but not at the
#   very beginning or very end, then return "Middle. For
#   example:
#   string_finder("Georgia Tech", "gia") -> "Middle"
#
# - If search string is not in target string at all, then
#   return "Not found". For example:
#   string_finder("Georgia Tech", "Idaho") -> "Not found"
#
#Assume that we're only interested in the first instance
#of the search string if it appears multiple times in the
#target string, and that search string is definitely
#shorter than target string.
#
#Hint: Don't be surprised if you find that the "End" case
#is the toughest! You'll need to look at the lengths of
#both the target string and the search string.


#Write your function here!
def string_finder(mainName, searchName):
    try:
        name = mainName.index(searchName)
        namelastindex = mainName[-1]
        searchlastindex =searchName[-1]
        if mainName[0] == searchName[0]:
            return "Beginning"
        elif not mainName[0] == searchName[0] and not mainName[-1] == searchName[-1]:
            return "Middle"
        elif mainName[-1] == searchName[-1]:
            return "End"
    except ValueError:
        return "Not found"






#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: Start, Middle, End, Not found, each on their own
#line.
print(string_finder("Georgia Tech", "Georgia"))
print(string_finder("Georgia Tech", "gia"))
print(string_finder("Georgia Tech", "Tech"))
print(string_finder("Georgia Tech", "Idaho"))

=================================================================================  9
#This one is a challenge. There's a lot going on: splitting
#up strings, removing unnecessary characters, converting to
#integers, and running a big conditional. Our solution to
#this is 34 lines -- you can do it!
#
#In web development, it is common to represent a color like 
#this:
#
#  rgb(red_val, green_val, blue_val)
#
#where red_val, green_val and blue_val would be substituted 
#with values from 0-255 telling the computer how much to 
#light up that portion of the pixel. For example:
#
# - rgb(255, 0, 0) would make a color red. 
# - rgb(255, 255, 0) would make yellow, because it is equal 
#   parts red and green. 
# - rgb(0, 0, 0) would make black, the absence of all color.
# - rgb(255, 255, 255) would make white, the presence of all
#   colors equally.
#
#Don't let the function-like syntax here confuse you: here,
#these are just strings. The string "rgb(0, 255, 0)"
#represents the color green.
#
#Write a function called "find_color" that accepts a single 
#argument expected to be a string as just described. Your
#function should return a simplified version of the color
#that is represented according to the following rules:
#
# If there is more red than any other color, return "red".
# If there is more green than any other color, return "green".
# If there is more blue than any other color, return "blue".
# If there are equal parts red and green, return "yellow".
# If there are equal parts red and blue, return "purple".
# If there are equal parts green and blue, return "teal".
# If there are equal parts red, green, and blue, return "gray".
# (even though this might be white or black).


#Write your function here!
def find_color(mystring):
    first = None
    second = None
    third = None
    param1 = None
    param2 = mystring.index(',')
    first = mystring[4:param2]
    # first =  str(first[-4:].strip(',-() '))

    param1 = mystring.index(' ')
    param2 = mystring.join(mystring.split(",", 2)[:2])
    second = mystring[param1:param1]
    second = str(param2[-4:].strip(',-() '))

    param1 = mystring.index(' ')
    param2 = mystring.join(mystring.split(",", 3)[:3])
    third = mystring[param1:param1]
    third = str(param2[-4:].strip(',-() '))
    if first == 0:
        if second == 0:
            if third == 0:
                return "gray"

    if first >= second and first >= third and first > 0:
        return "blue"
    elif second >= first and second > third:
        return "purple"
    elif first == 0 and second == 0 and third == 0:
        return "white"
    elif first == 255 and second == 255 and third == 255:
        return "black"
    elif third > first and third >= second:
         return "red"
    elif first == 0 and second == 0 and third == 0:
        return "white"
    else:
        return "gray"




#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: red, purple, gray, each on their own line.
print(find_color("rgb(125, 50, 75)"))
print(find_color("rgb(125, 17, 125)"))
print(find_color("rgb(217, 217, 217)"))

=============================================================================  10
#This one is a challenge. There's a lot going on: splitting
#up strings, removing unnecessary characters, converting to
#integers, and running a big conditional. Our solution to
#this is 34 lines -- you can do it!
#
#In web development, it is common to represent a color like 
#this:
#
#  rgb(red_val, green_val, blue_val)
#
#where red_val, green_val and blue_val would be substituted 
#with values from 0-255 telling the computer how much to 
#light up that portion of the pixel. For example:
#
# - rgb(255, 0, 0) would make a color red. 
# - rgb(255, 255, 0) would make yellow, because it is equal 
#   parts red and green. 
# - rgb(0, 0, 0) would make black, the absence of all color.
# - rgb(255, 255, 255) would make white, the presence of all
#   colors equally.
#
#Don't let the function-like syntax here confuse you: here,
#these are just strings. The string "rgb(0, 255, 0)"
#represents the color green.
#
#Write a function called "find_color" that accepts a single 
#argument expected to be a string as just described. Your
#function should return a simplified version of the color
#that is represented according to the following rules:
#
# If there is more red than any other color, return "red".
# If there is more green than any other color, return "green".
# If there is more blue than any other color, return "blue".
# If there are equal parts red and green, return "yellow".
# If there are equal parts red and blue, return "purple".
# If there are equal parts green and blue, return "teal".
# If there are equal parts red, green, and blue, return "gray".
# (even though this might be white or black).


#Write your function here!
def find_color(mystring):
    first = None
    second = None
    third = None
    param1 = None
    param2 = mystring.index(',')
    first = mystring[4:param2]
    # first =  str(first[-4:].strip(',-() '))

    param1 = mystring.index(' ')
    param2 = mystring.join(mystring.split(",", 2)[:2])
    second = mystring[param1:param1]
    second = str(param2[-4:].strip(',-() '))

    param1 = mystring.index(' ')
    param2 = mystring.join(mystring.split(",", 3)[:3])
    third = mystring[param1:param1]
    third = str(param2[-4:].strip(',-() '))
    if first == 0:
        if second == 0:
            if third == 0:
                return "gray"

    if first >= second and first >= third and first > 0:
        return "blue"
    elif second >= first and second > third:
        return "purple"
    elif first == 0 and second == 0 and third == 0:
        return "white"
    elif first == 255 and second == 255 and third == 255:
        return "black"
    elif third > first and third >= second:
         return "red"
    elif first == 0 and second == 0 and third == 0:
        return "white"
    else:
        return "gray"




#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: red, purple, gray, each on their own line.
print(find_color("rgb(125, 50, 75)"))
print(find_color("rgb(125, 17, 125)"))
print(find_color("rgb(217, 217, 217)"))

=================================================================== 11
#Now, let's improve our steps() function to take one parameter
#that represents the number of 'steps' to print. It should
#then return a string that, when printed, shows output like
#the following:
#
#print(steps(3))
#111
#	222
#		333
#
#print(steps(6))
#111
#	222
#		333
#			444
#				555
#					666
#
#Specifically, it should start with 1, and show three of each
#number from 1 to the inputted value, each on a separate
#line. The first line should have no tabs in front, but each
#subsequent line should have one more tab than the line
#before it. You may assume that we will not call steps() with
#a value greater than 9.
#
#Hint: You'll want to use a loop, and you'll want to create
#the string you're building before the loop starts, then add
#to it with every iteration.


#Write your function here!
def steps(noSteps):
    tab = '\t'
    value = ''
    for i in range(1, noSteps+1):
       
        value +=(str(i) * 3) + "\n" + "\t" * i
    return value + "\n"
   
    



#The following two lines will test your code, but are not
#required for grading, so feel free to modify them.
print(steps(3))
print(steps(6))

=======================================================================  12
#Write a function called after_second that accepts two 
#arguments: a target string to search, and string to search
#for. The  function should return everything in the first
#string *after* the *second* occurrence of the search term.
#You can assume  there will always be at least two
#occurrences of the search term in the first string. 
#
#For example:
#  after_second("11223344554321", "3") -> 44554321
#
#The search term "3" appears at indices 4 and 5. So, this
#returns everything from the index 6 to the end.
#
#  after_second("heyyoheyhi!", "hey") -> hi!
#
#The search term "hey" appears at indices 0 and 5. The
#search term itself is three characters. So, this returns
#everything from the index 8 to the end.
#
#Hint: This may be more complicated than it looks! You'll
#have to look at the length of the search string and
#either modify the target string or take advantage of the
#extra arguments you can pass to find().


#Write your function here!

def after_second(tString, sString):
    a = sString.join(tString.split(sString, 2)[:2])
    b = len(a)
    return tString[b + len(sString):]
    #return tString[len(a):]



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 44554321 and hi!, each on their own line.
print(after_second("11223344554321", "3"))
print(after_second("heyyoheyhi!", "hey"))

=========================================================================== 13
#Write a function called "replace_all" that accepts three 
#arguments:
#
# - target_string, a string in which to search.
# - find_string, a string to search for.
# - replace_string, a string to use to replace every instance
#   of the value of find.
#
#The arguments will be provided in this order. Your function
#should mimic the behavior of "replace", but you cannot use
#that function in your implementation. Instead, you should
#find the result using a combination of split() and join(),
#or some other method.
#
#Hint: This exercise can be complicated, but it can also
#be done in a single short line of code! Think carefully about
#the methods we've covered.


#Write your function here!
def replace_all(target_string, find_string, replace_string):
    sent = target_string.split()
    a = ""
    for word in sent:
        if find_string in word:
            if word == find_string:
                word = replace_string
            else:
                word = word.replace(find_string, replace_string)
        a += word + " "
    return a


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: "In case I don't see ya, bad afternoon, bad evening,
#and bad night!"
target = "Save time. Save money."
find = "Save"
replace = "Shave"
print(replace_all(target, find, replace))

======================================================================= 14
#Write a function called mock. mock should take one
#parameter, a string. You may assume that the string will
#have only lowercase letters and spaces.
#
#Your function should return the same string, but any letter
#at an even index should be converted to uppercase.
#
#For example: mock("abcd efgh ijkl") would return
#"AbCd eFgH IjKl".
#
#Remember, you can use the ordinal function ord() to get the
#number associated with a single letter. For example,
#ord("a") returns 97. The number associated with lowercase
#letters is always 32 larger than the number associated with
#the equivalent uppercase letter. ord("a") is 97, and
#ord("A") is 65. ord("z") is 122, and ord("Z") is 90.
#
#Remember, you can use the character function chr() to
#convert a number back to a letter. For example, chr(65) will
#return "A".
#
#HINT: Treat all characters the same initially, then worry
#about taking care of spaces afterwards.


#Write your function here!
def mock(mystring):
    count = 0
    result = ""
    for character in mystring:
        if count % 2 == 0:
            result += character.upper()
        else:
            result += character
        count += 1
    return result
        
            



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: "A square with side length 4 has an area of 16".

print(mock("abcd efgh ijkl"))

=======================================================================  15
#In the previous problem, you wrote a function that would
#convert text like "abcd efgh ijkl" into "AbCd eFgH IjKl".
#
#In the previous problem, you could assume the original
#string would be all lower-case, with no punctuation.
#
#Revise your function so that it no longer makes these
#assumptions. It should leave any punctuation marks or
#numerals unchanged, and it should change the case of
#every letter at an even index. That means if the letter
#is initially uppercase, it should be converted to lower
#case.
#
#For example: mock("Abcd. Efgh.. Ijkl!") would return
#"abCd. efGh.. IJkL!". The even-index letters (A, C, E, g,
#j, l) changed case, all other characters were unchanged.
#
#HINT: Lowercase letters always have an ordinal between
#97 ("a") and 122 ("z"). Uppercase letters always have an
#ordinal between 65 ("A") and 90 ("Z").


#Write your function here!
def mock(mystring):
    count = 0
    result = ""
    for character in mystring:
        if not character.isnumeric():
           if ord(character) % 2 == 0:
              if character.islower():
                  result += character.upper()
              else:
                  result += character.lower()
           else:
               result += character
           count += 1
    return result

#"abCd. efGh.. IJkL!"

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: "A square with side length 4 has an area of 16".


print(mock("Abcd. Efgh.. Ijkl!"))

===================================================================================  Coding Problem 4.3.1
#Write a function, called lucky_sevens, that takes in one
#parameter, a list of integers, and returns True if the list
#has three '7's  in a row and False if the list doesn't.
#
#For example:
#
#  lucky_sevens([4, 7, 8, 2, 7, 7, 7, 3, 4]) -> True
#  lucky_sevens([4, 7, 7, 2, 8, 3, 7, 4, 3]) -> False
#
#Hint: As soon as you find one instance of three sevens, you
#could go ahead and return True -- you only have to find it
#once for it to be True! Then, if you get to the end of the
#function and haven't returned True yet, then you might
#want to return False.


#Write your function here!
def lucky_sevens(myint):
    count = 0
    values = ""
    for value in myint:
        values += str(value)
    if '777' in values:
        return True
    else:
        return False



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: True, then False
print(lucky_sevens([4, 7, 8, 2, 7, 7, 7, 3, 4]))
print(lucky_sevens([4, 7, 7, 2, 8, 3, 7, 4, 3]))

==========================================================================  2
#Write a function called attendance_check. attendance_check
#should have two parameters: roster and present. Both roster
#and present will be lists of strings. Return a list (sorted
#alphabetically) of all strings in the list roster that are
#not in the list present. In other words, if roster is a
#list of students enrolled in a class and present is a list
#of students in class today, return a list of students that
#are absent.
#
#You may assume that every item in each list will be a
#string. You may also assume that every name in the list
#present will be in the list roster. If no students are
#absent, return an empty list.


#Write your function here!
def attendance_check(roster, present):
    results = []
    result = ""
    for inroster in present:
        for word in inroster:
           result += word
    for inpresent in roster:
        if not inpresent in result:
            results.append(inpresent)
    results.sort()
        
            
    return results


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 
#['Ferguson', 'Winston']
test_roster = ['Jessica', 'Nick', 'Winston', 'Schmidt', 'Cece', 'Ferguson']
test_present = ['Nick', 'Cece', 'Schmidt', 'Jessica']
print(attendance_check(test_roster, test_present))

==============================================================================  3
#Write a function called grade_scantron. grade_scantron should
#take as input two lists: answers and key. Each list contain
#strings. Each string will be only one letter, a character
#from A to E. grade_scantron should return how many questions
#the student got "right", where a student gets a question
#right if their answer for a problem matches the answer key.
#
#In other words, if value of the first item in answers matches
#the value of the first item in key, the student gets a point.
#If it does not, the student does not get a point.
#
#If the lists do not have the same number of items, return
#-1 to indicate that the answer key did not belong to the
#same test as the student's answers.\
#
#Hint: in the past, lots of people have tried to do this using
#the index() method. That won't work! You'll need to track the
#index yourself.


#Write your function here!
def grade_scantron(answers, keys):
    count = 0
    length = len(answers) -1
   
    try:
        while length >= 0:
            num = len(answers) -1
            num1 = len(keys) -1

            if num == num1: 
               if answers[length] == keys[length]:
                 count += 1
            elif count < 1 and length < 1:
                 count = -1
            length -= 1
        return count
    except:
          return -1
    

                



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 7
test_answers = ["A", "B", "B", "A", "D", "A", "B", "A", "E"]
test_key = ["A", "B", "B", "A", "D", "E", "B", "A", "D"]
print(grade_scantron(test_answers, test_key))

====================================================================================  4
#Write a function called solve_right_triangle. The function
#solve_right_triangle should have three parameters: (opposite, 
#adjacent, and use_degrees):. opposite and adjacent will be
#floats, and use_degrees will be a boolean. use_degrees
#should be a keyword parameter, and it should have a
#default value of False.
#
#The function should return a tuple containing the
#hypotenuse and angle of the right triangle (in that order).
#If use_degrees is False, the angle should be in radians.
#If use_degrees is True, the angle should be in degrees.
#
#Remember, the formula for the hypotenuse of a right
#triangle is the square root of the sum of the squared side
#lengths. You can find arctan using math.atan(), passing in
#the quotient of the opposite and adjacent as the argument.
#By default, math.atan() returns the angle in radians; you
#can pass that angle as an argument into the math.degrees()
#method to convert it to degrees; for example:
#
# angle_in_degrees = math.degrees(angle_in_radians)

import math


#Write your function here!
def solve_right_triangle(opposite, adjacent, use_degrees = False):
    hypotenuse = 0
    hypotenuse = math.sqrt(opposite ** 2 + adjacent ** 2)
    angle_in_degrees = 0
    angle_in_radians = math.atan(opposite / adjacent)
    if use_degrees:
        angle_in_degrees = math.degrees(angle_in_radians)
    elif not use_degrees:
        angle_in_degrees = angle_in_radians
    return (hypotenuse, angle_in_degrees)


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#(5.0, 0.6435011087932844)
#(5.0, 36.86989764584402)
print(solve_right_triangle(3.0, 4.0))
print(solve_right_triangle(3.0, 4.0, use_degrees = True))

===========================================================================  5
#Write a function called find_max_sales. find_max_sales will
#have one parameter: a list of tuples. Each tuple in the
#list will have two items: a string and an integer. The
#string will represent the name of a movie, and the integer
#will represent that movie's total ticket sales (in millions
#of dollars).
#
#The function should return the movie from the list that
#had the most sales. Return only the movie name, not the
#full tuple.


#Write your function here!
def find_max_sales(movieTuple):
    count = 0
    high = 0
    saleList = []
    nameList = []
    index = 0
    #(name,  sale) = movieTuple
    for movie in movieTuple:
        saleList.append(movie[1])
    for sale  in saleList:
        count += 1
        if sale > high:
            high = sale
            index = saleList.index(sale)

    for movie in movieTuple:
        nameList.append(movie[0])

    name = nameList[index]
    return  name.strip("'[,]'")

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: Rogue One
movie_list = [("Finding Dory", 486), ("Captain America: Civil War", 408), ("Deadpool", 363), ("Zootopia", 341), ("Rogue One", 529), ("The Secret Life of Pets", 368), ("Batman v Superman", 330), ("Sing", 268), ("Suicide Squad", 325), ("The Jungle Book", 364)]
print(find_max_sales(movie_list))

=========================================================================================  6
#Write a function called wish_list. wish_list should have
#four parameters, in this order: 
#
# - a list of strings, representing a list of items on a
#   wish list
# - a string, representing a particular item
# - a float, representing the cost of this item
# - a float, representing your budget
#
#If the item is on the list and you can afford it (cost is
#less than or equal to budget), return the string,
#"You should buy a [item name]!", replacing [item name]
#with the string.
#
#If the item is on the list but you can't afford it,
#return the string, "You should save up for a [item name]!",
#replacing [item name] with the string.
#
#If the item is not on the list, you should return the
#string "You probably don't want to buy a [item name].",
#replacing [item name] with the string.
#
#HINT: You do not need a loop to solve this. You can use
#one, but you don't need one.


#Add your function here!
def wish_list(list_of_strings, item_name, item_cost, budget):
    if item_name in list_of_strings:
        if item_cost <= budget:
            return "You should buy a "+ item_name+ "!"
        elif item_cost > budget:
            return "You should save up for a "+ item_name+ "!"
    else:
        return "You probably don't want to buy a "+ item_name+ "."



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: "You should save up for a bugle!"

wish_list_items = ["bugle", "trumpet", "banjo", "tuba"]
selected_item = "bugle"
item_cost = 199.99
budget = 150.00

print(wish_list(wish_list_items, selected_item, item_cost, budget))

===================================================================================  7
#Imagine you're writing some code for an exercise tracker.
#The tracker measures heart rate, and should display the
#average heart rate from an exercise session.
#
#However, the tracker doesn't automatically know when the
#exercise session began. It assumes the session starts the
#first time it sees a heart rate of 100 or more, and ends
#the first time it sees one under 100.
#
#Write a function called average_heart_rate.
#average_heart_rate should have one parameter, a list of
#integers. These integers represent heart rate measurements
#taken 30 seconds apart. average_heart_rate should return
#the average of all heart rates between the first 100+
#heart rate and the last one. Return this as an integer
#(use floor division when calculating the average).
#
#You may assume that the list will only cross the 100 beats
#per minute threshold once: once it goes above 100 and below
#again, it will not go back above.


#Add your function here!
def average_heart_rate(myIntegers):
    total = 0
    divisor = 0
    for value in myIntegers :
        if value >= 100:
            divisor += 1
            total += value
    return total // divisor
        



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 114 (because there are 14 measurements from 102 to
#101, their sum is 1609, and 1609 // 14 is 114).
beats = [72, 77, 79, 95, 102, 105, 112, 115, 120, 121, 121,
         125, 125, 123, 119, 115, 105, 101, 96, 92, 90, 85]
print(average_heart_rate(beats))

=============================================================================  8
#Write a function called string_splitter that replicates the
#function of the string type's split() method, assuming that
#we're splitting at spaces. string_splitter should take as
#input a string, and return as output a list of the
#individual words from the string, assuming that words were
#divided by spaces. The spaces themselves should not be in
#the list that your function returns.
#
#You may assume that there will never be more than one space
#in a row, and that the string will neither start nor end
#with a space. However, you should not assume there will
#always be a space.
#
#You may not use Python's built-in split() method.
#
#For example:
#
#  string_splitter("Hello world") -> ['Hello', 'world']


#Write your function here!
def string_splitter(myString):
    mylist = []
    characters = ""

    for character in myString:
        if not  " " == character:
              characters += character
        if " " == character:
            mylist.append(characters)
            characters = ""
            
    mylist.append(characters)
    return mylist
        


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: ['Hello', 'world']
print(string_splitter("Hello world"))
======================================================================  9
#A significant part of introductory physics is calculating
#the net force on an object based on several different
#magnitudes and directions. If you're unfamiliar with how
#this works, we recommend checking out this WikiHow article:
#https://www.wikihow.com/Find-Net-Force
#
#Each force acting on the object is defined by its angle and
#magnitude. The process for calculating net force is:
#
# - For each force, break the force into its horizontal and
#   vertical components. The horizontal component can be
#   calculated as magnitude * cos(angle), and the vertical
#   component can be calculated as magnitude * sin(angle).
# - Sum all the horizontal components to find the total
#   horizontal force, and sum the vertical components to find
#   the total vertical force.
# - Use the Pythagorean theorem to calculate the total
#   magnitude: sqrt(total_horizontal ^ 2 + total_vertical ^ 2)
# - Use inverse tangent to calculate the angle:
#   atan(total_vertical / total_horizontal)
#
#Write a function called find_net_force. find_net_force should
#take one parameter as input: a list of 2-tuples. Each 2-tuple
#in the list is a (magnitude, angle) pair. angle will be in
#degrees between -180 and 180.
#
#Return a 2-tuple containing the final magnitude and angle of
#all the forces. angle should again be in degrees. You should
#round both magnitude and angle to one decimal place, which
#you can do using round(magnitude, 1) and round(angle, 1).
#
#To do this, you'll need to use a few functions from the math
#module in Python. The line below will import these:

from math import sin, cos, tan, asin, acos, atan2, radians, degrees, sqrt

 

#sin, cos, and tan are the trigonometric functions for sine,
#cosine, and tangent. Each takes one argument, an angle in
#radians, and returns its sine, cosine, or tangent.
#
#asin, acos, and atan2 are their inverse functions. Each
#takes two arguments, a vertical component and a horizontal
#component (in that order), and returns the corresponding
#angle in radians.
#
#Note that sin, cos, and tan all assume the angle is in
#radians, and asin, acos, and atan2 will all return an
#angle in radians. So, you'll need to convert your angles to
#radians before or after using these functions, using things
#like this: angle_in_radians = radians(angle)
#           angle_in_degrees = degrees(angle_in_radians)

#sqrt will find the square root of a number, e.g. sqrt(4) = 2.
#Note that you should only need sin, cos, atan2, degrees,
#radians, and sqrt: we've imported the others just in case you
#want to use them.


#Add your function here!
def find_net_force(forces):
    total_horizontal = 0
    total_vertical = 0
    for force in forces:
        magnitude, angle = force
        angle = radians(angle)
        horizontal = magnitude * cos(angle)
        vertical = magnitude * sin(angle)
        total_horizontal += horizontal
        total_vertical += vertical
        
    net_magnitude = sqrt(total_horizontal**2 + total_vertical**2)
    
    net_magnitude = round(net_magnitude, 1)
    
    net_angle = atan2(total_vertical, total_horizontal)
    
    net_angle = degrees(net_angle)
    
    net_angle = round(net_angle, 1)
    
    return (net_magnitude, net_angle)


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: (87.0, 54.4)

forces = [(10, 90), (10, -90), (100, 45), (20, 180)]
print(find_net_force(forces))

============================================================================== 10
#Write a function called one_dimensional_booleans.
#one_dimensional_booleans should have two parameters:
#a list of booleans called bool_list and a boolean called
#use_and. You may assume that bool_list will be a list
#where every value is a boolean (True or False).
#
#The function should perform as follows:
#
# - If use_and is True, the function should return True if
#   every item in the list is True (simulating the and
#   operator).
# - If use_and is False, the function should return True if
#   any item in the list is True (simulating the or
#   operator).


#Write your function here!
def one_dimensional_booleans(bool_list, use_and):
     test = []
     count = 0
     max = 0
     string_list = ""
     for value in a_superlist:
        max = len(value)
        for string in value:
            count += 1
            string_list += str(string)
            if count == max:
                if   (not "False" in string_list) and use_and == True:
                    test.append(True)
                elif ("True" in string_list) and use_and == False:
                    test.append(True)
                else:
                    test.append(False)
        count = 0
        string_list =""
     return test
        



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: True, False, True, False.
print(one_dimensional_booleans([True, True, True], True))
print(one_dimensional_booleans([True, False, True], True))
print(one_dimensional_booleans([True, False, True], False))
print(one_dimensional_booleans([False, False, False], False))

===========================================================================  11
#Write a function called one_dimensional_booleans.
#one_dimensional_booleans should have two parameters:
#a list of booleans called bool_list and a boolean called
#use_and. You may assume that bool_list will be a list
#where every value is a boolean (True or False).
#
#The function should perform as follows:
#
# - If use_and is True, the function should return True if
#   every item in the list is True (simulating the and
#   operator).
# - If use_and is False, the function should return True if
#   any item in the list is True (simulating the or
#   operator).


#Write your function here!
def one_dimensional_booleans(bool_list, use_and):
     test = []
     count = 0
     max = 0
     string_list = ""
     for value in a_superlist:
        max = len(value)
        for string in value:
            count += 1
            string_list += str(string)
            if count == max:
                if   (not "False" in string_list) and use_and == True:
                    test.append(True)
                elif ("True" in string_list) and use_and == False:
                    test.append(True)
                else:
                    test.append(False)
        count = 0
        string_list =""
     return test
        



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: True, False, True, False.
print(one_dimensional_booleans([True, True, True], True))
print(one_dimensional_booleans([True, False, True], True))
print(one_dimensional_booleans([True, False, True], False))
print(one_dimensional_booleans([False, False, False], False))

==============================================================================  12
#Write a function called "angry_file_finder" that accepts a
#filename as a parameter. The function should open the file,
#read it, and return True if the file contains "!" on every
#line. Otherwise the function should return False. 
#
#Hint: there are lots of ways to do this. We'd suggest using
#either the readline() or readlines() methods. readline()
#returns the next line in the file; readlines() returns a
#list of all the lines in the file.


#Write your function here!
def angry_file_finder(filename):
    results = open(filename, 'r')
    holder = results.readlines()
    count = 0
    countv = 0


    for value in  holder:
        count += 1
        if "!" in value:
            countv += 1
    results.close()
    if count == countv:
        return True
    else:
        return False
   

        



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: True
print(angry_file_finder("AngryFileFinderInput.txt"))

================================================================================ 13
#Write a function called average_file. average_file should
#have one parameter: a filename.
#
#The file should have an integer on each line. average_file
#should return the average of these integers. However, if
#any of the lines of the file are _not_ integers,
#average_file should return the string "Error reading file!"
#
#Remember, by default, every time you read a line from a
#file, it's interpreted as a string.


#Add your function here!
def average_file(filename):

    result = open(filename, 'r')
    holder = result.readlines()
    count = 0
    sums = 0
    for value in holder:
        count += 1
        try:
            sums += int(value)
        except ValueError:
            return "Error reading file!"
    result.close()
    return sums / count      



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 5.0, then Error reading file!
#
#You can select valid_file.txt and invalid_file.txt from
#the dropdown in the top left to preview their contents.
print(average_file("valid_file.txt"))
print(average_file("invalid_file.txt"))

===============================================================================  14
#Write a function called st_dev. st_dev should have one
#parameter, a filename. The file will contain one integer on
#each line. The function should return the population standard
#deviation of those numbers.
#
#The formula for population standard deviation can be found here:
#edge.edx.org/asset-v1:GTx+gt-mooc-staging1+2018_T1+type@asset+block@stdev.PNG
#
#The formula is a bit complex, though, and since this is a
#CS class and not a math class, here are the steps you would
#take to calculate it manually:
#
# 1. Find the mean of the list.
# 2. For each data point, find the difference between that
#    point and the mean. Square that difference, and add it
#    to a running sum of differences.
# 4. Divide the sum of differences by the length of the
#    list.
# 5. Take the square root of the result.
#
#You may assume for this problem that the file will contain
#only integers -- you don't need to worry about invalid
#files or lines. The easiest way to take the square root is
#to raise it to the 0.5 power (e.g. 2 ** 0.5 will give the
#square root of 2).
#
#HINT: You might find this easier if you load all of the
#numbers into a list before trying to calculate the average.
#Either way, you're going to need to loop over the numbers
#at least twice: once to calculate the mean, once to
#calculate the sum of the differences.


#Add your function here!

import statistics
import math

def st_dev(filename):
    count = 0
    tot = 0
    diff = 0
    sumdiff = 0
    sqrsumdiff = 0
    mylist = []
    length = 0
    mean = 0
    result = open(filename, 'r')
    holder = result.readlines()
    length = len(holder)

    for value in holder:
        count += 1
        mylist.append(value.strip())
        tot += int(value.strip())
    mean =  tot / count 
   
    for value2 in mylist: 
        sumdiff += (int(value2) - mean) ** 2
    sqrsumdiff = (sumdiff / count) ** 0.5  
    
    
    return sqrsumdiff
    result.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 27.796382658340438 (or something around there).
print(st_dev("some_numbers.txt"))

=============================================================================== 15
#Recall Coding Problem 4.3.9 (Advanced), the free body
#diagram problem. If you were unable to solve that, we've
#included the sample answer in the dropdown in the top left
#-- feel free to use that to write your answer to this
#problem.
#
#Revise your code from that problem to use a file instead of
#a list as its parameter. Name this new function
#find_net_force_from_file. The function should take one
#parameter, the name of a file. The function should return
#the net magnitude and direction, just as it did in the other
#problem.
#
#Each line of the file will have two numbers, both integers:
#the first number will be the magnitude, and the second
#number will be the angle (in degrees, from -180 to 180).
#There will be a space between them.
#
#HINT: You may have multiple functions in your code if you
#want!
#
#HINT 2: Try to write this such that you can reuse as much
#of your earlier code as possible. Remember, when loading
#from a file, any text you load is initially a string. You'll
#almost certainly need to use the split() method.

from math import sin, cos, tan, asin, acos, atan2, radians, degrees, sqrt

#Add your function here!
def find_net_force_from_file(filename):
    content = open(filename, 'r')
    forces = content.readlines()
    values = []
    total_horizontal = 0
    total_vertical = 0
   
    
    for line in forces:
        line = line.strip().split(" ")        
        magnitude, angle = tuple([float(line[0]),float(line[1])])
           
        angle = radians(float(angle))
        horizontal = magnitude * cos(angle)
        vertical = magnitude * sin(angle)
        total_horizontal += horizontal
        total_vertical += vertical
        
    net_magnitude = sqrt(total_horizontal**2 + total_vertical**2)
    
    net_magnitude = round(net_magnitude, 1)
    
    net_angle = atan2(total_vertical, total_horizontal)
    
    net_angle = degrees(net_angle)
    
    net_angle = round(net_angle, 1)
    
    content.close()
        
    
    return (net_magnitude, net_angle)



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: (87.0, 54.4)
print(find_net_force_from_file("a_few_angles.txt"))

========================================================================  16
#Write a function called write_weird_file. write_weird_file
#should take two positional parameters. The first should be
#a filename, and the second should be a list. The function
#should also have three keyword parameters: mode, sort_first
#and reverse_first. The default value for mode should be "w",
#and the default values for both sort_first and reverse_first
#should be False.
#
#write_weird_file should write the contents of the list to
#the given filename. Each item from the list should be on a
#separate line. The list items could be strings, floats, 
#characters, or integers. If the mode is "w", it should
#overwrite the current contents; if the mode is "a", it
#should append to the current contents. You may assume there
#will be no other value for mode.
#
#If sort_first is True, it should sort the list before
#writing. If reverse_first is True, then it should reverse
#the list before writing. If both are True, it should sort,
#then reverse.


#Add your function here!
def write_weird_file(filename, a_list, mode ='w', sort_first = False, reverse_first = False):
    content = open(filename, mode)
    output = []
    for value in a_list:
        output.append(str(value))
    if sort_first == True:
        output.sort()

    for value in output:
        content.write(str(value) + "\n")
    content.close()




#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing. However, if you open the file called
#output.txt in the top left after running it, the contents
#of the file should be:
#Wait, where'd the other text go?
#It's gone!
#3
#2
#1
write_weird_file("output.txt", ["Hmm, I bet this text will disappear.", "I wonder where it will go?"])
write_weird_file("output.txt", ["Wait, where'd the other text go?", "It's gone!"])
write_weird_file("output.txt", [2, 1, 3], mode="a", sort_first=True, reverse_first=True)

=========================================================================================  17
#This is a long one -- our answer is 20 lines of code, but
#yours will probably be longer. That's because it's one of the
#more authentic problems we've done so far. This is a real
#problem you'll start to face if you want to start creating
#useful programs.
#
#One of the reasons that filetypes work is that everyone 
#agrees how they are structured. A ".png" file, for example, 
#always contains "PNG" in the first four characters to 
#assure the program that the file is actually a png. If these
#standards were not set, it would be hard to write programs 
#that know how to open and read the file. 
#
#Lets define a new filetype called ".cs1301". 
#In this file, every line should be structured like so:
#
#number assignment_name grade total weight
#
#In this file, each component will meet the following
#description:
#
# - number: an integer-like value of the assignment number 
#
# - assignment_name: a string value of the assignment name
#
# - grade: an integer-like value of a students grade
#
# - total: an integer-like value of the total possible
#   number of points
#
# - weight: a float-like value ranging from 0 to 1 
#   representing the percent of the students grade this 
#   assignment is worth. All the weights should add up to 1.
#
#Each component should be separated with exactly one space. 
#A good sample file is available to view as 
#"sample.cs1301".
#
#Write a function called format_checker that accepts a 
#filename and returns True if the file contents accurately 
#conform to the described format. Otherwise the function 
#should return False. In other words, it should return True
#if:
#
# - Each line has five elements separated by spaces, AND
# - The first, third, and fourth elements are integers, AND
# - The fifth element is a decimal number, AND
# - All the fifth elements add to 1.
#
#You can make changes to test.cs1301 to test your function,
#or test it with sample.cs1301. Right now, running it on
#sample.cs1301 should return True, and on test.cs1301
#should return False.
#
#Hint 1: .split() will likely help separate each line into 
#its components.
#Hint 2: .split() returns a list. So, if you were to do
#something like say split_line = line.split(), then
#split_line[0] would give the first item, split_line[1] would
#give the second item, etc.
#Hint 3: If you're having trouble, try breaking it down by
#parts. First check the file to see if it has the right
#number of items per line, then whether the items are of
#the correct type, then whether the fifth elements add to
#1. Remember, you know how to do each individual check
#(checking types, adding numbers, finding list lengths) --
#the hard part is knitting this all together into one bigger
#solution.


#Write your function here!
def format_checker(input_file):
    reading_list = []
    file_name = open(input_file, "r")
    for i in file_name:
        reading_list.append(i.strip().split())
    file_name.close()
   
    try:
       
        weight_count = []
        for sub_list in reading_list:
            if not len(sub_list) == 5:
                return False
            else:
               
                count = 0
                for i in sub_list:
                    if count == 0:
                        location = count
                        sub_list.remove(i)
                        sub_list.insert(location, int(i))
                        count += 1
                    elif count == 1:
                        location = count
                        sub_list.remove(i)
                        sub_list.insert(location, str(i))
                        count += 1
                    elif count == 2:
                        location = count
                        sub_list.remove(i)
                        sub_list.insert(location, int(i))
                        count += 1
                    elif count == 3:
                        location = count
                        sub_list.remove(i)
                        sub_list.insert(location, int(i))
                        count += 1
                    elif count == 4:
                        location = count
                        sub_list.remove(i)
                        sub_list.insert(location, float(i))
                        count += 1
                        
                        weight_count.append(float(i))
    except ValueError:
        pass
    finally:
        
        if sum(weight_count) == 1:
            return True
        else:
            return False



#Test your function below. With the original values of these
#files, these should print True, then False:
print(format_checker("sample_1.cs1301"))
print(format_checker("sample_2.cs1301"))

======================================================================================= 18
#Write a function called "reader" that reads in a ".cs1301" 
#file described in the previous problem. The function should 
#return a list of tuples representing the lines in the file like so:
#
#[(line_1_number, line_1_assignment_name, line_1_grade, line_1_total, line_1_weight), 
#(line_2_number, line_2_assignment_name, line_2_grade, line_2_total, line_2_weight)]
#
#All items should be of type int except for the name (string) 
#and the weight (float). You can assume the file will be in the 
#proper format -- in a real program, you would use your code
#from the previous problem to check for formatting before
#trying to call the function below.
#
#Hint: Although you could use readlines() to read in all
#the lines at once, they would all be strings, not a list.
#You still need to go line-by-line and convert each string
#to a list.


#Write your function here!
def reader(input_file):
    reading_list = []
    file_name = open(input_file, "r")
    for i in file_name:
        reading_list.append(i.strip().split())
    file_name.close()
    try:
        #var for tracking the weight
        weight_count = []
        reading_list_length = len(reading_list)
        for sub_list in reading_list:
            outer_list_count = 0
            count = 0
            for i in sub_list:
                if count == 0:
                    location = count
                    sub_list.remove(i)
                    sub_list.insert(location, int(i))
                    count += 1
                elif count == 1:
                    location = count
                    sub_list.remove(i)
                    sub_list.insert(location, str(i))
                    count += 1
                elif count == 2:
                    location = count
                    sub_list.remove(i)
                    sub_list.insert(location, int(i))
                    count += 1
                elif count == 3:
                    location = count
                    sub_list.remove(i)
                    sub_list.insert(location, int(i))
                    count += 1
                elif count == 4:
                    location = count
                    sub_list.remove(i)
                    sub_list.insert(location, float(i))
                    count += 1
                    # append value to weight tracking list
                    weight_count.append(float(i))
            if outer_list_count < reading_list_length:
                new_tuple = tuple(sub_list)
                location = outer_list_count
                reading_list.remove(sub_list)
                reading_list.insert(location, new_tuple)
    except ValueError:
        pass
    reading_list.reverse()
    return reading_list
    


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 
#[(1, 'assignment_1', 85, 100, 0.25), (2, 'test_1', 90, 100, 0.25), (3, 'exam_1', 95, 100, 0.5)]
print(reader("sample.cs1301"))

===================================================================================== 19
#Write a function called write_1301 which will write a file
#in the format described in Coding Problem 4.4.2. The
#sample.cs1301 file has been included to refresh your 
#memory. Your function should accept two arguments:
#A string of a filename to write to, and a list of tuples. 
#You can assume that each tuple will have the following 
#format:
#
#(int, str, int, int, float)
#
#Each tuple will represent a line in the file, and each
#item in the tuple should correspond to the 
#assignment number, the assignment name, the student's 
#grade, the total possible number of points, and the 
#assignment weight respectively. 


#Write your function here!
def write_1301(ouput_file, list_of_tuples):
    filename = open(ouput_file, mode="w")
    for my_tuple in list_of_tuples:
        my_string = str(my_tuple)
        my_string = my_string.replace(",", "")
        my_string = my_string.replace("'", "")
        my_string = my_string.replace(")", "")
        my_string = my_string.replace("(", "")
        print(my_string, file = filename)
    filename.close()


#The code below will test your function. It's not used
#for grading, so feel free to modify it! You may check
#output.cs1301 to see how it worked.
tuple1 = (1, "exam_1", 90, 100, 0.6)
tuple2 = (2, "exam_2", 95, 100, 0.4)
tupleList = [tuple1, tuple2]
write_1301("output.cs1301", tupleList)

=================================================================================  20
#Write a function called get_grade that will read a
#given .cs1301 file and return the student's grade.
#To do this, we would recommend you first pass the
#filename to your previously-written reader() function,
#then use the list that it returns to do your
#calculations. You may assume the file is well-formed.
#
#A student's grade should be 100 times the sum of each
#individual assignment's grade divided by its total,
#multiplied by its weight. So, if the .cs1301 just had
#these two lines:
#
# 1 exam_1 80 100 0.6
# 2 exam_2 30 50 0.4
#
#Then the result would be 72:
#
# (80 / 100) * 0.6 + (30 / 50) * 0.4 = 0.72 * 100 = 72


#Write your function here!
def get_grade(filename):
    inputFile = open(filename,"r")
    data = inputFile.readlines()
    
    c=[]
    for line in data:
        a=line.strip("\n")
        b=a.split(" ")
        [a_val, b_val, c_val, d_val, e_val]=b
        a_val=int(a_val)
        c_val=int(c_val)
        d_val=int(d_val)
        e_val=float(e_val)
        b=[a_val, b_val, c_val, d_val, e_val]
        c.append(b)
    grade_n=0
    for item in c:
        grade=(item[2]/item[3])*item[4]
        grade_n+=grade
    return grade_n*100
    inputFile.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 91.55 
print(get_grade("sample.cs1301"))

=========================================================================== 21
#We've given you a file called "top500.txt" which contains
#the name and lifetime gross revenue of the top 500
#films at the time this question was written. 
#
#Each line of the given file is formatted like so:
# <name>\t<gross revenue in dollars>
#
#In other words, you should call .split("\t") to split
#the line into the movie name (the first item) and the
#gross (the second item).
#
#Unfortunately, these movies are not in order. Write a 
#function called "sort_films" that accepts two parameters:
#a string of a source filename and a string of a
#destination filename. Your function should open the
#source file and sort the contents from greatest gross
#revenue to least gross revenue, and write the sorted
#contents to the destination filename. You may assume the
#source file is correctly formatted.
#
#Hint: one common issue on this problem is that every line
#in the input file ends with a line break except the last
#one. If the autograder gives you an index error, open
#top500result.txt and make sure there are 500 lines in your
#output file!


#Write your function here!
def sort_films(filename, destination):
    mylist =[]
    inputFile=open(filename, "r")
    for line in inputFile:
        b=line.split("\t")
        c=b[1].strip("\n")
        mylist.append(c)
        mylist.sort(reverse=True)
    inputFile=open(filename, "r")
    num_lines = sum(1 for line in open(filename))
    i=0
    for i in range(len(mylist)):
        outputFile=open(destination, "a")
        for line in open(filename):
            b=line.split("\t")
            c=b[1].strip("\n")
            if mylist[i]==c:
                print(b[0]+"\t",c,file=outputFile)
                i+=1
                break
            else:
                pass
    inputFile.close()


#The line of code below will test your function and put
#your results in top500result.txt. Then, it will print
#"Done!"
sort_films("top500.txt", "top500result.txt")
print("Done!")

=============================================================================== Coding Problem 4.5.1
#Write a function called phonebook that takes two lists as
#input:
#
# - names, a list of names as strings
# - numbers, a list of phone numbers as strings
#
#phonebook() should take these two lists and create a
#dictionary that maps each name to its phone number. For
#example, the first name in names should become a key in
#the dictionary, and the first number in numbers should
#become the value corresponding to the first name. Then, it
#should return the dictionary that results.
#
#Hint: Because you're mapping the first name with the first
#number, the second name with the second number, etc., you do
#not need two loops. For a similar exercise, check back on
#Coding Problem 4.3.3, the Scantron grading problem.
#
#You may assume that the two lists have the same number of
#items: there will be no names without numbers or numbers
#without names.


#Write your function here!
def phonebook(names, numbers):
    phone_dict = {}
    count = 0
    for name in names:
        phone_dict[name] = numbers[count]
        count += 1
    return phone_dict



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'Jackie': '404-555-1234', 'Joshua': '678-555-5678', 'Marguerite': '770-555-9012'

name_list = ['Jackie', 'Joshua', 'Marguerite']
number_list = ['404-555-1234', '678-555-5678', '770-555-9012']
print(phonebook(name_list, number_list))

================================================================================ 2
#Do not change the line of code below. It's at the top of
#the file to ensure that it runs before any of your code.
#You will be able to access french_dict from inside your
#function.
french_dict = {"me": "moi", "hello": "bonjour", 
               "goodbye": "au revoir", "cat": "chat", 
               "dog": "chien", "and": "et"}

#Write a function called french2eng that takes in one string
#parameter called sentence. french2eng should look at each
#word in the sentence and translate it into French if it is
#found in the dictionary, french_dict. If a word is not found
#in the dictionary, do not translate it: use the original
#word. Then, the function should return a string of the
#translated sentence.
#
#You may assume that the sentence you're translating has no
#punctuation. However, you should convert it to lower case
#before translating.
#
#For example:
#
#  french2eng("Hello it's me") -> "bonjour it's moi"
#
#Hint: Use .split() to get a list of strings representing
#each word in the string, then use ' '.join to merge the
#translated list back into one string.
#
#Hint 2: Remember, lists are mutable, so we can change
#individual items in the list. However, to change an item
#in a list, we must change it using its index. We can
#write lines like my_words[1] = new_word.
#
#Hint 3: If you're stuck, try breaking it down into small
#parts. How do you access an item from a list? How do you
#look up a key in a dictionary? How do you change the
#value of an item in a list? How do you check if a key is
#in the dictionary?


#Write your function here!
def french2eng(sentence):
    lowersent = sentence.lower()
    words = lowersent.split()
    searchstring = ""
    sent =""
    for word in words:
        if word in french_dict.keys():
            sent += french_dict[word] + " "
        else:
            sent += word + " "
    return sent



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: bonjour it's moi
print(french2eng("Hello it's me"))

===========================================================================  3
#Write a function called course_info that takes as input a
#list of tuples. Each tuple contains two items: the first
#item in each tuple is a student's name as a string, and the
#second item in each tuple is that student's age as an
#integer.
#
#The function should return a dictionary with two keys.
#The key "students" should have as its value a list of all
#the students (in other words, a list made from the first
#value of each tuple), in the original order in which they
#appeared in the list. The key "avg_age" should have as its
#value a float representing the average age of all the
#students in the list (in other words, the average of all
#the second items in the tuples).
#
#For example:
#
#  course_info([("Jackie", 20), ("Marguerite", 21)])
#  -> {"students": ['Jackie', 'Marguerite'], "avg_age": 20.5}
#
#Hint: Concentrate first on building the list of students
#and calculating the average age. Save creating the
#dictionary for last.


#Write your function here!
def course_info(tuplist):
    dictio={}
    xlist=[]
    avg_age=0
    for tupl in tuplist:
        xlist.append(tupl[0])
        avg_age+=tupl[1]
    dictio["students"]=xlist
    dictio["avg_age"]=avg_age/len(tuplist)
    return dictio



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
print(course_info([("Jackie", 20), ("Marguerite", 21)]))

===============================================================================  4
#Write a function called modify_dict. modify_dict takes one
#parameter, a dictionary. The dictionary's keys are people's
#last names, and the dictionary's values are people's first
#names. For example, the key "Joyner" would have the value
#"David".
#
#modify_dict should delete any key-value pair for which the
#key's first letter is not capitalized. For example, the
#key-value pair "joyner":"David" would be deleted, but the
#key-value pair "Joyner":"david" would not be deleted. Then,
#return the modified dictionary.
#
#Remember, the keyword del deletes items from lists and
#dictionaries. For example, to remove the key "key!" from
#the dictionary my_dict, you would write: del my_dict["key!"]
#Or, if the key was the variable my_key, you would write:
#del my_dict[my_key]
#
#Hint: If you try to delete items from the dictionary while
#looping through the dictionary, you'll run into problems!
#We should never change the number if items in a list or
#dictionary while looping through those items. Think about
#what you could do to keep track of which keys should be
#deleted so you can delete them after the loop is done.
#
#Hint 2: To check if the first letter of a string is a
#capital letter, use string[0].isupper().


#Write your function here!
def modify_dict(my_dict):
    xlist=[]
    for (key, value) in my_dict.items():
        if str(key).islower():
            xlist.append(key)
        else:
            pass
    for item in xlist:
        del my_dict[item]
    return my_dict



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#  {'Diaddigo':'Joshua', 'Elliott':'jackie'}
my_dict = {'Joshua':'Diaddigo', 'joyner':'David', 'Elliott':'jackie', 'murrell':'marguerite'}
print(modify_dict(my_dict))

===========================================================================================  5
#-----------------------------------------------------------
#Recall in an earlier problem you were given two lists: one
#list was a student's answers to a test, and the other was
#the answer key. Your goal was to return a score
#representing the number of problems the student got correct.
#
#Let's do that again, but with dictionaries instead of lists.
#Write a function called calculate_score. calculate_score
#should take two parameters: a dictionary of student answers
#and a dictionary of correct answers. Both dictionaries should
#have integers as their keys, and one-character strings as
#their values.
#
#calculate_score should count how many questions the student
#got right. Or, in more precise terms, calculate_score should
#count how many keys for which the associated value is the
#same in the student's dictionary and in the answer key
#dictionary.
#
#As before, it is possible that there will be more answers in
#one than the other. This means that these answers don't
#belong to the same test! If that happens, return -1.


#Add your function here!
def calculate_score(dictionary, student_a):
    count = 0
    count_q = len(dictionary.items())
    count_a = len(student_a.items())
    
    for value in dictionary.items():
        for k in student_a.items():
            if count_q == count_a:
                if value[0] == k[0] and value[1] == k[1]:
                    count +=1
            else:
                return -1
    return count



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 3
student_answers = {1: 'D', 2: 'A', 3: 'B', 4: 'E', 5: 'C', 6: 'E', 7: 'C', 8: 'E', 9: 'B', 10: 'D', 11: 'E', 12: 'B', 13: 'B', 14: 'E', 15: 'E', 16: 'C', 17: 'E'}
correct_answers = {1: 'D', 2: 'A', 3: 'B', 4: 'E', 5: 'D', 6: 'C', 7: 'C', 8: 'E', 9: 'B', 10: 'D', 11: 'E'}
print(calculate_score(student_answers, correct_answers))

======================================================================================  6
#In the Pokemon video game series, every Pokemon has six
#stats: HP, Attack, Defense, Special Attack, Special Defense,
#and Speed.
#
#Write a function called total_stats that will take as input
#a list of dictionaries. Each dictionary will have seven
#key-value pairs:
#
# - name: a Pokemon's name
# - hp, attack, defense, special attack, special defense,
#   and speed: an integer representing that Pokemon's stat
#   in that category
#
#Your function should return a single dictionary. The keys
#of the dictionary should be the Pokemon names from the
#original list, and the values should be the _total_ stats
#for each Pokemon (add HP, Attack, Defense, Special Attack,
#Special Defense, and Speed).
#
#For example, if this was one of the dictionaries in the
#original list:
#
#{"name": "Bulbasaur", "hp": 45, "attack": 49, "defense": 49,
#"special attack": 65, "special defense": 65, "speed": 45}
#
#Then one of the key-value pairs in the dictionary you
#return would be: "Bulbasaur": 318 (45 + 49 + 49 + 65 + 65 +
#45 = 318).


#Add your function here!
def total_stats(dictionary):
    mydict = {} 
    for rec in dictionary:
         mydict[rec['name']] = int(rec["hp"]) + int(rec["attack"]) + int(rec["defense"]) +                                              int(rec["special attack"]) + int(rec["special defense"]) + int(rec["speed"])
    return mydict

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'Bulbasaur': 318, 'Charmander': 309, 'Squirtle': 314}
starters = [{"name": "Bulbasaur", "hp": 45, "attack": 49, "defense": 49, "special attack": 65, "special defense": 65, "speed": 45},
            {"name": "Charmander", "hp": 39, "attack": 52, "defense": 43, "special attack": 60, "special defense": 50, "speed": 65},
            {"name": "Squirtle", "hp": 44, "attack": 48, "defense": 65, "special attack": 50, "special defense": 64, "speed": 43}]
print(total_stats(starters))

======================================================================================  7
#Write a function called population_density. The function
#should take one parameter, which will be a list of
#dictionaries. Each dictionary in the list will have three
#key-value pairs:
#
# - name: the name of the country
# - population: the population of that country
# - area: the area of that country (in km^2)
#
#Your function should return the population density of all
#the countries put together. You can calculate this by
#summing all the populations, summing all the areas, and
#dividing the total population by the total area.
#
#Note that the input to this function will look quite long;
#don't let that scare you. That's just because dictionaries
#take a lot of text to define.


#Add your function here!
def population_density(list_dc):
    pop = 0
    tot = 0
    for rec in list_dc:
        pop += int(rec["population"])
        tot += int(rec["area"])
    return pop / tot
    


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 133.886 (or something around there)
countries = [{"name": "China", "population": 1390700000, "area": 9640821},
             {"name": "India", "population": 1348003000, "area": 3287240},
             {"name": "United States", "population": 325300000, "area": 9826675},
             {"name": "Indonesia", "population": 237556363, "area": 1904569}]
print(population_density(countries))
             
=============================================================================================  8
#Write a function called word_lengths, which takes in one
#parameter, a string, and returns a dictionary where each
#word of the string is mapped to an integer representing how
#how long that word is. You should ignore punctuation, and
#all the words should be lowercase. You can assume that the
#only punctuation marks in the string will be periods,
#commas, question marks, exclamation points, and apostrophes.
#
#For example:
#  word_lengths("I ate a bowl of cereal out of a dog bowl today.")
#  -> {'i':1, 'bowl':4, 'today':5, 'out':3, 'dog':3, 'ate':3,
#      'a':1, 'of':2, 'cereal':6}
#
#Hint: Use the split() method to split by spaces, and don't
#forget to remove punctuation marks.  Remember also: strings
#are immutable, so operations like my_string.lower() don't
#change the value of my_string like list methods: to save
#those results, you'd write my_string = my_string.lower().
#
#Your dictionary should not have any duplicate keys (in fact,
#Python won't allow a dictionary to have duplicate keys).


#Write your function here!
def word_lengths(myString):
    myString = myString.replace("!","")
    myString = myString.replace("?","")
    myString = myString.replace(".","")
    myString = myString.replace(",","")
    myString = myString.replace("'","")
   
    myString = myString.lower()
    mysplitString = myString.split(" ")
    dictionery={}
    for word in mysplitString:
        index=len(word)
        dictionery[word]=index
    return dictionery



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#{'dog': 3, 'today': 5, 'of': 2, 'ate': 3, 'bowl': 4, 'out': 3, 'a': 1, 'cereal': 6, 'i': 1}
#
#The order of the keys may differ, but that's okay!
print(word_lengths("I ate a bowl of cereal out of a dog bowl today."))

=============================================================================== 9
#Recall last exercise that you wrote a function, word_lengths,
#which took in a string and returned a dictionary where each
#word of the string was mapped to an integer value of how
#long it was.
#
#This time, write a new function called length_words so that
#the returned dictionary maps an integer, the length of a
#word, to a list of words from the sentence with that length.
#If a word occurs more than once, add it more than once. The
#words in the list should appear in the same order in which
#they appeared in the sentence.
#
#For example:
#
#  length_words("I ate a bowl of cereal out of a dog bowl today.")
#  -> {3: ['ate', 'dog', 'out'], 1: ['a', 'a', 'i'],
#      5: ['today'], 2: ['of', 'of'], 4: ['bowl'], 6: ['cereal']}
#
#As before, you should remove any punctuation and make the
#string lowercase.
#
#Hint: To create a new list as the value for a dictionary key,
#use empty brackets: lengths[wordLength] = []. Then, you would
#be able to call lengths[wordLength].append(word). Note that
#if you try to append to the list before creating it for that
#key, you'll receive a KeyError.


#Write your function here!
def length_words(myString):
    myString = myString.replace(".", "")
    myString = myString.replace(",", "")
    myString = myString.replace("?", "")
    myString = myString.replace("!", "")
    myString = myString.replace("'", "")
    myString = myString.lower()
    mySplittedString = myString.split()
    word_dictionary = {}
    for word in mySplittedString:
        word_length = len(word)
        if word_length in word_dictionary:
            word_dictionary[word_length].append(word)
        else:
            word_dictionary[word_length] = []
            word_dictionary[word_length].append(word)
    return word_dictionary




#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#{1: ['i', 'a', 'a'], 2: ['of', 'of'], 3: ['ate', 'out', 'dog'], 4: ['bowl', 'bowl'], 5: ['today'], 6: ['cereal']}
#
#The keys may appear in a different order, but within each
#list the words should appear in the order shown above.
print(length_words("I ate a bowl of cereal out of a dog bowl today."))

==================================================================================  10
#Write a function called most_oscars, which takes in one
#parameter, a dictionary. This dictionary maps names to the
#number of Academy Awards for which they have been nominated.
#This function should return a tuple containing the name and
#number of nominations for the person who has the most
#nominations.
#
#You may assume there will not be a tie for the actor with
#the most nominations (although there may be other ties in
#the list).


#Write your function here!
def most_oscars(dicti):
    mylist = []
    count  = 1
    b = ()
    for (key,value) in dicti.items():
        if value > count:
            count = value
            b = (key, value)
        else:
            pass
    return b


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: ('Meryl Streep', 20)
nominees = {'Meryl Streep': 20, 'Robert De Niro': 7, 'Michael Caine': 6, 'Maggie Smith': 6}
print(most_oscars(nominees))

========================================================================================  11
#Recall in coding problem 4.4.3 that you wrote a function
#called "reader" that read a .cs1301 file and returned a
#list of lists.
#
#Let's revise that problem. Instead of a list of lists,
#that's return a dictionary of dictionaries.
#
#Write a function called "reader" that takes one parameter,
#a filename as a string corresponding to a .cs1301 file,
#and reads in that .cs1301 file.
#
#Each line of the .cs1301 file will have five items, each
#separated by a space: the first, third, and fourth will
#represent integers, the second will be a string, and the
#fifth will represent a float. (Note: when reading the
#file, these will all be strings; you can assume each of
#these strings can be converted to the corresponding data
#type, however.)
#
#The function should return a dictionary of dictionaries
#representing the file contents.
#
#The keys of the top-level dictionary should be the
#assignment names. Then, the value for each of those keys
#should be a dictionary with four keys: "number", "grade",
#"total", and "weight". The values corresponding to each of
#those four keys should be the values from the file,
#converted to the corresponding data types (ints or floats).
#
#For example, if the input file read:
#
# 1 exam_1 90 100 0.6
# 2 exam_2 95 100 0.4
#
#Then reader would return this dictionary of dictionaries:
#
# {"exam_1": {"number": 1, "grade": 90, "total": 100, "weight": 0.6},
#  "exam_2": {"number": 2, "grade": 95, "total": 100, "weight": 0.4}}
#
#Hint: Although the end result is pretty different, this
#should only dictate a minor change to your original
#Problem 4.4.3 code!


#Write your function here!
def reader(filename):
    data = open(filename, "r")
    mydict = {}
    for line in data:
        line = line.strip("\n")
        mylist = line.split(" ")
        mydict[mylist[1]]={"total":int(mylist[3]), "number":int(mylist[0]), "grade":int(mylist[2]), "weight":float(mylist[4])}
    return mydict
    outputFile.close()



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'assignment_1': {'total': 100, 'number': 1, 'grade': 85, 'weight': 0.25}, 'test_1': {'total': 100, 'number': 2, 'grade': 90, 'weight': 0.25}, 'exam_1': {'total': 100, 'number': 3, 'grade': 95, 'weight': 0.5}} 
print(reader("sample.cs1301"))

========================================================================================  12
#This is a challenging one! The output will be very long as
#you'll be working on some pretty big dictionaries. We don't
#expect everyone to be able to do it, but it's a good chance
#to test how far you've come!
#
#Write a function called stars that takes in two
#dictionaries:
#
# - movies: a dictionary where the keys are movie titles and
#   the values are lists of major performers in the movie. For
#   example: movies["The Dark Knight"] = ["Christian Bale",
#   "Heath Ledger", "Maggie Gyllenhall", "Aaron Eckhart"]
# - tvshows: a dictionary where the keys are TV show titles
#   and the values lists of major performers in the show.
#   For example: tvshows["Community"] = ["Joel McHale", "Alison
#   Brie", "Danny Pudi", "Donald Glover", "Yvette Brown"]
#
#The function stars should return a new dictionary. The keys
#of the new dictionary should be the performers' names, and
#the values for each key should be the list of shows and
#movies in which that performer has appeared. Sort the shows
#and movies alphabetically.


#Write your function here!
def stars(movies, shows):
    mydict={}
    for (key,value) in movies.items():
        for item in value:
            if item in mydict:
                mydict[item].append(key)
            else:
                mydict[item]=[key]
    for (key,value) in shows.items():
        for item in value:
            if item in mydict:
                mydict[item].append(key)
            else:
                mydict[item]=[key]
    for (key,value) in mydict.items():
        value.sort()            
    return mydict

    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{'Portia de Rossi': ['Arrested Development'], 'Will Ferrell': ['The Lego Movie'], 'Yvette Brown': ['Community'], 'Rebel Wilson': ['How to Be Single'], 'Danny Pudi': ['Community'], 'Elizabeth Banks': ['30 Rock', 'The Lego Movie'], 'Alec Baldwin': ['30 Rock'], 'Alison Brie': ['Community', 'How to Be Single', 'The Lego Movie'], 'Tina Fey': ['30 Rock'], 'Dakota Johnson': ['How to Be Single'], 'Joel McHale': ['Community'], 'Jack McBrayer': ['30 Rock'], 'Tracy Morgan': ['30 Rock'], 'Donald Glover': ['Community'], 'Will Arnett': ['Arrested Development', 'The Lego Movie'], 'Jason Bateman': ['Arrested Development']}

movies = {"How to Be Single": ["Alison Brie", "Dakota Johnson",
                               "Rebel Wilson"],
          "The Lego Movie": ["Will Arnett", "Elizabeth Banks",
                             "Alison Brie", "Will Ferrell"]}
tvshows = {"Community": ["Alison Brie", "Joel McHale",
                         "Danny Pudi", "Yvette Brown",
                         "Donald Glover"],
           "30 Rock": ["Tina Fey", "Tracy Morgan", "Jack McBrayer",
                       "Alec Baldwin", "Elizabeth Banks"],
           "Arrested Development": ["Jason Bateman", "Will Arnett",
                                    "Portia de Rossi"]}
print(stars(movies, tvshows))

======================================================================================= 13



















